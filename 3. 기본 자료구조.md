# 3. 기본 자료구조

## 리스트 (`list`)

리스트는 Python에서 가장 기본적이고 널리 사용되는 **시퀀스 자료형**이다. **여러 개의 값을 순차적으로 저장**할 수 있으며, 각각의 요소는 인덱스를 통해 접근할 수 있다. 리스트는 **가변형(mutable)** 객체로, 생성 후에도 내용을 변경할 수 있는 것이 가장 큰 특징이다.

### ✅ 리스트 생성

```
empty = []                 # 빈 리스트
numbers = [1, 2, 3, 4, 5]  # 정수 리스트
mixed = [1, "two", 3.0]    # 다양한 자료형 혼합 가능
nested = [[1, 2], [3, 4]]  # 중첩 리스트 (2차원)
```

리스트는 `list()` 생성자를 사용하여 다른 iterable 객체로부터 생성할 수도 있다.

```
chars = list("hello")  # ['h', 'e', 'l', 'l', 'o']
```

### 🔢 인덱싱과 슬라이싱

| 기능          | 문법                    | 설명             |
| ------------- | ----------------------- | ---------------- |
| 인덱싱        | `lst[0]`, `lst[-1]`     | 특정 요소 접근   |
| 슬라이싱      | `lst[1:4]`, `lst[:3]`   | 범위 추출        |
| 스텝 슬라이스 | `lst[::2]`, `lst[::-1]` | 간격 혹은 뒤집기 |

예시:

```
lst = [10, 20, 30, 40, 50]

lst[0]     # 10
lst[-1]    # 50
lst[1:4]   # [20, 30, 40]
lst[::-1]  # [50, 40, 30, 20, 10]
```

### 🔧 리스트 변경

```
lst = [1, 2, 3]
lst[0] = 100        # 값 변경
lst.append(4)       # 맨 뒤에 추가
lst.insert(1, 200)  # 특정 위치에 삽입
lst.extend([5, 6])  # 여러 개 추가

lst.remove(2)       # 값으로 삭제 (첫 번째 항목)
del lst[0]          # 인덱스로 삭제
popped = lst.pop()  # 마지막 항목 제거 + 반환

lst.clear()         # 전체 비우기
```

### 🔎 리스트 탐색

```
lst = [10, 20, 30, 20]

lst.index(20)       # 20의 첫 번째 인덱스 → 1
lst.count(20)       # 20의 개수 → 2
20 in lst           # True
50 not in lst       # True
```

### 📏 리스트 길이 및 순회

```
lst = [1, 2, 3]

len(lst)            # 길이: 3

for item in lst:
    print(item)
```

`enumerate()`로 인덱스와 값을 동시에 꺼낼 수 있다:

```
for idx, val in enumerate(lst):
    print(idx, val)
```

### 📐 정렬과 뒤집기

```
nums = [3, 1, 4, 1, 5]

nums.sort()          # 오름차순 정렬 (원본 변경)
nums.sort(reverse=True)  # 내림차순 정렬
nums.reverse()       # 단순히 순서 뒤집기

sorted_nums = sorted(nums)  # 원본 유지, 새 리스트 반환
```

### 🧪 리스트 컴프리헨션

```
squares = [x**2 for x in range(5)]        # [0, 1, 4, 9, 16]
evens = [x for x in range(10) if x % 2 == 0]
```

### 🧮 리스트 연산자

| 연산자 | 설명              | 예시              | 결과                 |
| ------ | ----------------- | ----------------- | -------------------- |
| `+`    | 리스트 이어붙이기 | `[1, 2] + [3, 4]` | `[1, 2, 3, 4]`       |
| `*`    | 반복              | `[1, 2] * 3`      | `[1, 2, 1, 2, 1, 2]` |
| `in`   | 포함 여부 확인    | `3 in [1, 2, 3]`  | `True`               |

### 🔗 중첩 리스트

```
matrix = [
    [1, 2],
    [3, 4]
]

matrix[0][1]  # 2
```

2차원 이상의 구조도 리스트를 통해 자유롭게 표현할 수 있다.

### 🎯 요약

| 메서드         | 기능 설명                            |
| -------------- | ------------------------------------ |
| `append(x)`    | 끝에 요소 추가                       |
| `insert(i, x)` | i번째 위치에 요소 삽입               |
| `remove(x)`    | 첫 번째로 나오는 x 제거              |
| `pop([i])`     | i번째 요소 꺼내며 삭제 (기본 마지막) |
| `sort()`       | 정렬                                 |
| `reverse()`    | 역순 변경                            |
| `clear()`      | 전체 요소 삭제                       |
| `count(x)`     | x의 개수 반환                        |
| `index(x)`     | x의 첫 인덱스 반환                   |
| `extend(iter)` | 반복 가능한 객체 확장 추가           |

리스트는 Python 프로그래밍의 핵심이며, 대부분의 자료구조와 알고리즘의 기반이 된다. 실무에서도 JSON, 데이터 분석, API 결과 처리 등 수많은 작업에 리스트가 사용된다.

## 튜플 (`tuple`)

튜플은 Python의 기본 시퀀스 자료형 중 하나로, **리스트와 매우 유사하지만 수정할 수 없는(immutable)** 자료구조다. 튜플은 한 번 정의하면 **요소의 추가, 삭제, 변경이 불가능**하다는 점에서 리스트와 구별된다. 불변성을 기반으로 **데이터 보호, 해시 가능성, 성능 최적화** 등의 목적에서 널리 사용된다.

### ✅ 튜플 생성

튜플은 소괄호 `()`로 감싸거나, 쉼표 `,`만으로도 생성할 수 있다.

```
t1 = (1, 2, 3)
t2 = "a", "b", "c"      # 괄호 생략 가능
t3 = (42,)              # 요소가 하나인 튜플 (쉼표 필요)
t4 = tuple([1, 2, 3])   # list → tuple 변환
```

### ⚠️ 요소 하나짜리 튜플은 쉼표로 구분

```
not_a_tuple = (1)     # 그냥 정수형
actual_tuple = (1,)   # 진짜 튜플
```

### 🔎 인덱싱과 슬라이싱

튜플도 시퀀스이므로 인덱싱과 슬라이싱이 모두 가능하다.

```
t = (10, 20, 30, 40, 50)

t[0]     # 10
t[-1]    # 50
t[1:4]   # (20, 30, 40)
```

### ♻️ 반복과 멤버십

```
for item in t:
    print(item)

print(30 in t)     # True
print(99 not in t) # True
```

### 🔁 변경 불가능한 구조

튜플은 불변이므로 다음과 같은 조작은 **오류를 발생시킨다**.

```
t[0] = 100        # TypeError
del t[1]          # TypeError
```

단, 튜플 안에 리스트처럼 **mutable 객체가 들어있다면 그 내부는 변경 가능**하다.

```
t = ([1, 2], 3)
t[0][0] = 99
print(t)  # ([99, 2], 3)
```

### 🔄 packing & unpacking

튜플은 자동으로 **묶기(packing)** 또는 **풀기(unpacking)** 를 지원한다.

```
a, b = (1, 2)     # unpacking
p = 1, 2          # packing
```

#### 여러 개 한꺼번에 할당

```
x, y, z = (10, 20, 30)
print(x, y, z)  # 10 20 30
```

### 📐 튜플 함수와 메서드

| 함수/메서드 | 설명          |
| ----------- | ------------- |
| `len()`     | 길이 반환     |
| `count(x)`  | x의 개수      |
| `index(x)`  | x의 첫 인덱스 |

```
t = (1, 2, 2, 3)

len(t)       # 4
t.count(2)   # 2
t.index(3)   # 3
```

### 🧯 튜플 사용 이유

- **불변성**: 함수 인자, 딕셔너리 키로 안전하게 사용 가능
- **성능**: 리스트보다 메모리 사용량이 적고 처리 속도가 빠름
- **명확한 의미 부여**: 변경하지 않을 값을 튜플로 선언함으로써 의도를 코드에 드러냄
- **해시 가능**: 튜플은 `set`, `dict`의 키로 사용 가능하지만 리스트는 불가능

```
my_dict = {(1, 2): "좌표값"}
```

### 🧪 실전 예: 좌표 리스트

```
points = [(0, 0), (1, 2), (3, 5)]

for x, y in points:
    print(f"x={x}, y={y}")
```

### 🎯 요약

| 항목        | 리스트 (`list`)   | 튜플 (`tuple`)      |
| ----------- | ----------------- | ------------------- |
| 가변성      | 변경 가능         | 변경 불가           |
| 사용 목적   | 일반 데이터, 가공 | 고정 데이터, 안전성 |
| 기호        | `[]`              | `()`                |
| 메서드 수   | 많음              | 적음                |
| 딕셔너리 키 | 불가능            | 가능                |

튜플은 **안정적이고 변경되지 않아야 하는 데이터**를 표현할 때 사용하는 것이 좋다. 또한 여러 값의 반환, 여러 변수 동시에 할당 등의 **구조화된 데이터 표현**에 널리 쓰인다.

## 딕셔너리 (`dict`)

Python의 딕셔너리(`dict`)는 **키(key)-값(value) 쌍의 집합**으로 구성된 자료형이다. 이는 **연관 배열(associative array)** 또는 **해시맵(hash map)** 으로도 불리며, **순서 없는 변경 가능한 컬렉션**이다. Python 3.7 이후부터는 삽입 순서도 유지된다.

### ✅ 딕셔너리 생성

```
empty = {}  # 빈 딕셔너리
person = {
    "name": "Alice",
    "age": 30,
    "is_student": False
}
```

`dict()` 생성자도 사용 가능:

```
person = dict(name="Bob", age=25)
```

### 🔑 키와 값의 특징

- **키는 고유해야 하며 불변 객체여야 함** (예: str, int, tuple 등)
- **값은 어떤 자료형이든 가능**

```
d = {
    1: "one",
    (2, 3): "tuple as key",
    "key": [1, 2, 3]
}
```

⚠️ 리스트나 딕셔너리처럼 변경 가능한 객체는 키로 사용할 수 없음

### 🧭 값 접근 및 수정

```
person["name"]          # 'Alice'
person["age"] = 31      # 값 수정
person["job"] = "Dev"   # 새 키 추가
```

접근 시 존재하지 않는 키를 참조하면 `KeyError`가 발생하므로, `get()` 메서드를 사용하는 것이 안전하다:

```
person.get("name")       # 'Alice'
person.get("salary", 0)  # 기본값 0 반환
```

### ❌ 키 삭제

```
del person["age"]
removed = person.pop("job")  # 값을 꺼내며 삭제
```

`clear()`로 전체 삭제도 가능:

```
person.clear()
```

### 🔍 딕셔너리 순회

```
for key in person:
    print(key, person[key])
```

혹은 명시적으로 `keys()`, `values()`, `items()` 사용:

```
for k in person.keys():
    print(k)

for v in person.values():
    print(v)

for k, v in person.items():
    print(f"{k} → {v}")
```

### 🧪 딕셔너리 관련 함수 및 메서드

| 메서드               | 설명                        |
| -------------------- | --------------------------- |
| `get(key, default)`  | 키의 값 반환, 없으면 기본값 |
| `keys()`             | 모든 키 반환                |
| `values()`           | 모든 값 반환                |
| `items()`            | (키, 값) 튜플 반환          |
| `pop(key)`           | 키를 제거하며 해당 값 반환  |
| `update(other_dict)` | 다른 딕셔너리 병합          |
| `clear()`            | 모든 항목 제거              |

```
d = {"a": 1, "b": 2}
d.update({"b": 20, "c": 30})
# 결과: {'a': 1, 'b': 20, 'c': 30}
```

### 🧯 키 존재 확인

```
if "name" in person:
    print("name 키가 존재함")
```

### 🧪 실전 예: 단어 빈도수 세기

```
text = "apple banana apple grape banana apple"
word_count = {}

for word in text.split():
    word_count[word] = word_count.get(word, 0) + 1

print(word_count)
# {'apple': 3, 'banana': 2, 'grape': 1}
```

### 🎯 요약

| 항목           | 설명                               |
| -------------- | ---------------------------------- |
| 자료구조       | 키:값 쌍                           |
| 키 자료형      | 불변형만 가능 (str, int, tuple 등) |
| 값 자료형      | 제한 없음                          |
| 순서 보존      | O (Python 3.7+)                    |
| 변경 가능 여부 | 가능 (mutable)                     |
| 접근 속도      | 평균 O(1) (해시 기반)              |

딕셔너리는 **구조화된 데이터 저장**, **빠른 조회**, **속성 표현**, **객체 구성 요소 관리** 등 거의 모든 실전 프로그래밍에서 핵심 도구로 사용된다.

## 집합 (`set`)

Python의 `set` 자료형은 **중복되지 않는 요소들의 무순서 집합**이다. 수학적 집합과 유사한 개념이며, **중복 제거**, **교집합·합집합·차집합 연산**, **빠른 포함 검사** 등에 사용된다.
 내부적으로 해시 테이블을 사용하므로 평균 연산 속도가 매우 빠르다.

### ✅ 집합 생성

```
empty_set = set()               # 빈 집합 ({}는 dict임에 주의)
fruits = {"apple", "banana", "cherry"}  # 중괄호를 이용한 초기화
nums = set([1, 2, 3, 1, 2])     # 중복 자동 제거 → {1, 2, 3}
```

⚠️ `{}`만 사용하면 빈 딕셔너리가 만들어진다. 빈 집합은 `set()`으로 생성해야 함

### 🚫 중복 허용 X, 순서 없음

```
a = {1, 2, 2, 3, 3, 3}
print(a)  # {1, 2, 3}
```

리스트와 달리 인덱스로 접근할 수 없다. 순서가 없기 때문이다.

```
a[0]  # TypeError 발생
```

### 🔁 순회

```
for item in {"a", "b", "c"}:
    print(item)
```

순서 보장 안 됨에 유의. 무작위처럼 출력될 수 있음.

### 🔨 주요 메서드

| 메서드       | 설명                         |
| ------------ | ---------------------------- |
| `add(x)`     | 요소 추가                    |
| `remove(x)`  | 요소 삭제 (없으면 에러)      |
| `discard(x)` | 요소 삭제 (없어도 에러 없음) |
| `clear()`    | 모든 요소 제거               |
| `pop()`      | 임의 요소 제거 및 반환       |
| `copy()`     | 얕은 복사                    |

```
s = {1, 2, 3}
s.add(4)
s.remove(2)
s.discard(99)  # 에러 없음
s.pop()
```

### 🔁 집합 연산 (수학적 연산)

| 연산   | 연산자 | 메서드                   | 설명               |
| ------ | ------ | ------------------------ | ------------------ |
| 합집합 | `      | `                        | `union()`          |
| 교집합 | `&`    | `intersection()`         | 공통 요소만        |
| 차집합 | `-`    | `difference()`           | 왼쪽에만 있는 요소 |
| 대칭차 | `^`    | `symmetric_difference()` | 한쪽에만 있는 요소 |

```
a = {1, 2, 3}
b = {3, 4, 5}

a | b  # {1, 2, 3, 4, 5}
a & b  # {3}
a - b  # {1, 2}
a ^ b  # {1, 2, 4, 5}
```

### 🔍 포함 관계 연산

| 메서드              | 설명                 |
| ------------------- | -------------------- |
| `issubset(other)`   | 부분집합 여부        |
| `issuperset(other)` | 상위집합 여부        |
| `isdisjoint(other)` | 교집합이 없는지 확인 |

```
a = {1, 2}
b = {1, 2, 3}

a.issubset(b)     # True
b.issuperset(a)   # True
a.isdisjoint({4}) # True
```

### 🧪 실전 예: 중복 제거

```
names = ["Tom", "Jerry", "Tom", "Mike"]
unique_names = set(names)
print(unique_names)  # {'Jerry', 'Mike', 'Tom'}
```

### 📌 불변 집합 `frozenset`

변경이 불가능한 집합으로, 딕셔너리 키 등에 사용할 수 있다.

```
f = frozenset([1, 2, 3])
# f.add(4) → 오류: 'frozenset' object has no attribute 'add'
```

### 🎯 요약

| 항목           | `set`                                      |
| -------------- | ------------------------------------------ |
| 중복 허용      | ❌                                          |
| 순서 보장      | ❌ (3.7부터 내부적으로는 유지되지만 보장 X) |
| 인덱스 접근    | ❌                                          |
| 변경 가능 여부 | ✅                                          |
| 주요 기능      | 집합 연산, 빠른 검색, 중복 제거            |

집합은 **빠른 검색, 데이터 정제, 수학적 연산 처리** 등 다양한 상황에서 활용된다. 리스트보다 느리게 보일 수 있지만 `in` 연산에서의 성능 차이는 매우 크다 (O(1) vs O(n)).

## 내장 함수 및 순회 기법

Python은 반복 가능한 객체(`iterable`)를 처리할 수 있는 다양한 **내장 함수**와 **순회(이터레이션) 도구**를 제공한다. 이들은 코드의 간결함과 효율성을 높이며, 특히 컬렉션 데이터를 다룰 때 매우 강력한 기능을 발휘한다.

### 🔁 기본 반복 구조

모든 iterable 객체(`list`, `tuple`, `dict`, `set`, `str`, `range`)는 `for` 루프를 통해 순회할 수 있다.

```
for x in [10, 20, 30]:
    print(x)

for ch in "hello":
    print(ch)
```

### 🔎 주요 내장 순회 함수

| 함수             | 설명                        |
| ---------------- | --------------------------- |
| `enumerate()`    | 인덱스와 값을 동시에 반환   |
| `zip()`          | 여러 시퀀스를 병렬로 묶음   |
| `range()`        | 숫자 시퀀스 생성            |
| `map()`          | 함수를 모든 요소에 적용     |
| `filter()`       | 조건을 만족하는 요소만 추출 |
| `reversed()`     | 역순 반복                   |
| `sorted()`       | 정렬된 시퀀스 반환          |
| `any()`          | 하나라도 참이면 True        |
| `all()`          | 모두 참이어야 True          |
| `sum()`          | 숫자들의 합 반환            |
| `min()`, `max()` | 최솟값, 최댓값 반환         |

### 🧮 `enumerate()` — 인덱스 포함 반복

```
fruits = ["apple", "banana", "cherry"]

for idx, fruit in enumerate(fruits):
    print(f"{idx}: {fruit}")
```

출력:

```
0: apple  
1: banana  
2: cherry
```

### 🔗 `zip()` — 병렬 순회

```
names = ["Tom", "Jerry", "Spike"]
scores = [90, 85, 77]

for name, score in zip(names, scores):
    print(f"{name}: {score}")
```

출력:

```
Tom: 90  
Jerry: 85  
Spike: 77
```

`zip()`은 가장 짧은 길이를 기준으로 순회가 종료된다.

### 🔁 `range()` — 정수 시퀀스 생성

```
range(5)          # 0, 1, 2, 3, 4
range(1, 6)       # 1, 2, 3, 4, 5
range(1, 10, 2)   # 1, 3, 5, 7, 9
```

`for` 루프에서 가장 흔히 사용되는 반복 생성기

### 🔀 `map()` — 함수 일괄 적용

```
nums = [1, 2, 3]
squares = list(map(lambda x: x ** 2, nums))
# [1, 4, 9]
```

`map()`은 게으른 연산자(lazy)라서 list로 감싸야 결과 확인 가능

### 🔍 `filter()` — 조건 필터링

```
nums = [1, 2, 3, 4, 5]
even = list(filter(lambda x: x % 2 == 0, nums))
# [2, 4]
```

### ⏮ `reversed()` — 역순 순회

```
for x in reversed([1, 2, 3]):
    print(x)
```

### 🧼 정렬 관련 함수

```
sorted([3, 1, 2])           # [1, 2, 3]
sorted(["b", "a", "c"])     # ['a', 'b', 'c']
sorted(["a", "bb", "ccc"], key=len)  # ['a', 'bb', 'ccc']
```

`sorted()`는 원본을 변경하지 않음
 `list.sort()`는 원본을 직접 정렬함

### 🔍 집계 함수

```
nums = [10, 20, 30, 40]

sum(nums)       # 100
min(nums)       # 10
max(nums)       # 40
any(nums)       # True (하나라도 참이면)
all(nums)       # True (0이나 False가 없으면)
```

예외: `all([1, 2, 0])` → `False`
 `any([0, 0, 3])` → `True`

### 🧪 실전 예: 학생 점수 평가

```
students = ["A", "B", "C"]
scores = [85, 62, 90]

for name, score in zip(students, scores):
    result = "합격" if score >= 70 else "불합격"
    print(f"{name}: {score}점 → {result}")
```

### 🎯 요약

| 함수                      | 핵심 용도             |
| ------------------------- | --------------------- |
| `enumerate()`             | 인덱스 + 값           |
| `zip()`                   | 여러 시퀀스 병렬 순회 |
| `range()`                 | 반복 시퀀스 생성      |
| `map()`                   | 모든 요소에 함수 적용 |
| `filter()`                | 조건에 맞는 요소만    |
| `reversed()`              | 역방향 순회           |
| `sorted()`                | 정렬된 시퀀스 반환    |
| `sum()`, `min()`, `max()` | 숫자 집계             |
| `any()`, `all()`          | 조건 체크             |

이 함수들과 반복 기법들은 Python을 **더 간결하고 표현력 있게 만드는 핵심 도구**다. 함수형 프로그래밍 스타일과 결합하면 복잡한 로직도 짧은 코드로 처리할 수 있다.